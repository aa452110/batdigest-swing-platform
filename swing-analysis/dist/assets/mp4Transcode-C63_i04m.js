var s;(function(r){r.LOAD="LOAD",r.EXEC="EXEC",r.FFPROBE="FFPROBE",r.WRITE_FILE="WRITE_FILE",r.READ_FILE="READ_FILE",r.DELETE_FILE="DELETE_FILE",r.RENAME="RENAME",r.CREATE_DIR="CREATE_DIR",r.LIST_DIR="LIST_DIR",r.DELETE_DIR="DELETE_DIR",r.ERROR="ERROR",r.DOWNLOAD="DOWNLOAD",r.PROGRESS="PROGRESS",r.LOG="LOG",r.MOUNT="MOUNT",r.UNMOUNT="UNMOUNT"})(s||(s={}));const R=(()=>{let r=0;return()=>r++})(),u=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),h=new Error("called FFmpeg.terminate()");class w{#t=null;#a={};#r={};#s=[];#o=[];loaded=!1;#n=()=>{this.#t&&(this.#t.onmessage=({data:{id:t,type:e,data:a}})=>{switch(e){case s.LOAD:this.loaded=!0,this.#a[t](a);break;case s.MOUNT:case s.UNMOUNT:case s.EXEC:case s.FFPROBE:case s.WRITE_FILE:case s.READ_FILE:case s.DELETE_FILE:case s.RENAME:case s.CREATE_DIR:case s.LIST_DIR:case s.DELETE_DIR:this.#a[t](a);break;case s.LOG:this.#s.forEach(o=>o(a));break;case s.PROGRESS:this.#o.forEach(o=>o(a));break;case s.ERROR:this.#r[t](a);break}delete this.#a[t],delete this.#r[t]})};#e=({type:t,data:e},a=[],o)=>this.#t?new Promise((l,i)=>{const n=R();this.#t&&this.#t.postMessage({id:n,type:t,data:e},a),this.#a[n]=l,this.#r[n]=i,o?.addEventListener("abort",()=>{i(new DOMException(`Message # ${n} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(u);on(t,e){t==="log"?this.#s.push(e):t==="progress"&&this.#o.push(e)}off(t,e){t==="log"?this.#s=this.#s.filter(a=>a!==e):t==="progress"&&(this.#o=this.#o.filter(a=>a!==e))}load=({classWorkerURL:t,...e}={},{signal:a}={})=>(this.#t||(this.#t=t?new Worker(new URL(t,import.meta.url),{type:"module"}):new Worker(new URL("/assets/worker-BAOIWoxA.js",import.meta.url),{type:"module"}),this.#n()),this.#e({type:s.LOAD,data:e},void 0,a));exec=(t,e=-1,{signal:a}={})=>this.#e({type:s.EXEC,data:{args:t,timeout:e}},void 0,a);ffprobe=(t,e=-1,{signal:a}={})=>this.#e({type:s.FFPROBE,data:{args:t,timeout:e}},void 0,a);terminate=()=>{const t=Object.keys(this.#r);for(const e of t)this.#r[e](h),delete this.#r[e],delete this.#a[e];this.#t&&(this.#t.terminate(),this.#t=null,this.loaded=!1)};writeFile=(t,e,{signal:a}={})=>{const o=[];return e instanceof Uint8Array&&o.push(e.buffer),this.#e({type:s.WRITE_FILE,data:{path:t,data:e}},o,a)};mount=(t,e,a)=>{const o=[];return this.#e({type:s.MOUNT,data:{fsType:t,options:e,mountPoint:a}},o)};unmount=t=>{const e=[];return this.#e({type:s.UNMOUNT,data:{mountPoint:t}},e)};readFile=(t,e="binary",{signal:a}={})=>this.#e({type:s.READ_FILE,data:{path:t,encoding:e}},void 0,a);deleteFile=(t,{signal:e}={})=>this.#e({type:s.DELETE_FILE,data:{path:t}},void 0,e);rename=(t,e,{signal:a}={})=>this.#e({type:s.RENAME,data:{oldPath:t,newPath:e}},void 0,a);createDir=(t,{signal:e}={})=>this.#e({type:s.CREATE_DIR,data:{path:t}},void 0,e);listDir=(t,{signal:e}={})=>this.#e({type:s.LIST_DIR,data:{path:t}},void 0,e);deleteDir=(t,{signal:e}={})=>this.#e({type:s.DELETE_DIR,data:{path:t}},void 0,e)}var f;(function(r){r.MEMFS="MEMFS",r.NODEFS="NODEFS",r.NODERAWFS="NODERAWFS",r.IDBFS="IDBFS",r.WORKERFS="WORKERFS",r.PROXYFS="PROXYFS"})(f||(f={}));const m=r=>new Promise((t,e)=>{const a=new FileReader;a.onload=()=>{const{result:o}=a;o instanceof ArrayBuffer?t(new Uint8Array(o)):t(new Uint8Array)},a.onerror=o=>{e(Error(`File could not be read! Code=${o?.target?.error?.code||-1}`))},a.readAsArrayBuffer(r)}),p=async r=>{let t;if(typeof r=="string")/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(r)?t=atob(r.split(",")[1]).split("").map(e=>e.charCodeAt(0)):t=await(await fetch(r)).arrayBuffer();else if(r instanceof URL)t=await(await fetch(r)).arrayBuffer();else if(r instanceof File||r instanceof Blob)t=await m(r);else return new Uint8Array;return new Uint8Array(t)};let c=null,E=null;async function D(){return c&&E?(await E,c):(c=new w,E=(async()=>{try{const r="https://unpkg.com/@ffmpeg/core-mt@0.12.6/dist/esm";await c.load({coreURL:`${r}/ffmpeg-core.js`,wasmURL:`${r}/ffmpeg-core.wasm`,workerURL:`${r}/ffmpeg-core.worker.js`}),console.log("[MP4Transcode] FFmpeg loaded successfully")}catch(r){throw console.error("[MP4Transcode] Failed to load FFmpeg:",r),r}})(),await E,c)}async function O(r,t){try{console.log("[MP4Transcode] Starting transcode, input size:",r.size);const e=await D();t&&e.on("progress",({progress:n})=>{const d=Math.round(n*100);console.log(`[MP4Transcode] Progress: ${d}%`),t(d)});const a="input.webm",o="output.mp4";await e.writeFile(a,await p(r)),console.log("[MP4Transcode] Input file written"),await e.exec(["-i",a,"-c:v","libx264","-preset","fast","-crf","23","-c:a","aac","-b:a","128k","-movflags","+faststart","-pix_fmt","yuv420p","-vf","scale=trunc(iw/2)*2:trunc(ih/2)*2",o]),console.log("[MP4Transcode] Transcode complete");const l=await e.readFile(o),i=new Blob([l],{type:"video/mp4"});console.log("[MP4Transcode] Output MP4 size:",i.size);try{await e.deleteFile(a),await e.deleteFile(o)}catch(n){console.warn("[MP4Transcode] Cleanup error:",n)}return t&&e.off("progress"),i}catch(e){throw console.error("[MP4Transcode] Transcode failed:",e),new Error(`Failed to transcode video: ${e}`)}}export{O as transcodeWebMToMP4};
